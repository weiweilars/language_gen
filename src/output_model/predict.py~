import glob
import cv2
import os
import pdb
import numpy as np
from skimage import color
import pdb
from model import SegPredModel
from src.datamodules.datasets.predict_dataset import SegInfDataset
from src.datamodules.datasets.dataset import SegDataset
from torch.utils.data import DataLoader
import torch


data_folder = './data/seg_data/'
model_path = './data/model/epoch=67-step=113355.ckpt'



def predict(type='real'):

    trained_model = SegPredModel(path_to_model=model_path, device='cuda')
    
    # print model hyperparameters
    print(trained_model.hparams)

    image_params = trained_model.hparams['image']


    if type == 'real':
        data_path = os.path.join(data_folder, 'test_real')

        test_images = glob.glob(data_path+'/*.jpg')
        test_images.sort()

        input_images = []
        for img in test_images:
            input_images.append(cv2.imread(img, cv2.IMREAD_GRAYSCALE))


        dataset=SegInfDataset(input_images, data_path, image_params['heigh'], image_params['width'], image_params['resize'])

        inputs = DataLoader(dataset=dataset, batch_size=1, shuffle=False)

    else:
        data_path = os.path.join(data_folder, 'test')
        
        dataset=SegDataset(10, data_folder, image_params['heigh'], image_params['width'], image_params['resize'], data_name='test')

        inputs = DataLoader(dataset=dataset, batch_size=1, shuffle=False)
    
    
    ## get the cut image or extend images
    preprocessed_files = glob.glob(data_path+'/image'+'/*.jpg')
    preprocessed_files.sort()
    preprocessed_images = []


    for img in preprocessed_files:
        
        pre_img = cv2.imread(img, cv2.IMREAD_GRAYSCALE)
    
        preprocessed_images.append(pre_img)

    result_path = os.path.join(data_path,'result')

    if not os.path.exists(result_path):
        os.makedirs(result_path)


    for idx, input in enumerate(inputs):

        pre_img = preprocessed_images[idx]

        if type == 'fake':
            input = input[0]
        
        result = trained_model.predict(input)
        
        np_mask = cv2.resize(result, (pre_img.shape[0], pre_img.shape[1]), interpolation=cv2.INTER_NEAREST)

        # np.save(os.path.join(result_path, 'mask', str(idx)), np_mask)
    
        color_mask = np.zeros((np_mask.shape[0], np_mask.shape[1], 3))
        color_mask[np_mask==1] = [255, 0, 0]  
        color_mask[np_mask==2] = [255, 128, 0] 
        color_mask[np_mask==3] = [255, 255, 0] 
        color_mask[np_mask==4] = [128, 255, 0] 
        color_mask[np_mask==5] = [0, 255, 0]  
        color_mask[np_mask==6] = [0, 255, 255] 
        color_mask[np_mask==7] = [0, 0, 255] 
        color_mask[np_mask==8] = [127, 0, 255] 
        color_mask[np_mask==9] = [255, 51, 255]  
    
        img_color = np.dstack((pre_img, pre_img, pre_img))

        img_hsv = color.rgb2hsv(img_color)
        color_mask_hsv = color.rgb2hsv(color_mask)

        img_hsv[..., 0] = color_mask_hsv[..., 0]
        img_hsv[..., 1] = color_mask_hsv[..., 1] * 0.3

        img_masked = color.hsv2rgb(img_hsv)*255

        cv2.imwrite(os.path.join(result_path, str(idx) + "-mask.png"), img_masked)
    


if __name__ == "__main__":
    predict(type='real')
